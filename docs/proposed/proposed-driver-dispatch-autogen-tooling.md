Proposal for PSA driver dispatch code generation
===================================================

This document contains a design proposal for the tooling in Mbed TLS to generate dispatch code/modules for PSA drivers.

## Applicable specifications

* [Driver interface](psa-driver-interface.html): for driver writers (and PSA crypto core implementers). specification of the C interfaces of drivers and of JSON driver descriptions. Mostly complete.
* [Driver developer's guide](psa-driver-developer-guide.html): for driver writers. Concrete steps to write a driver and provide the necessary files to use it in Mbed TLS. Work in progress.
* [Driver integration guide](psa-driver-integration-guide.html): for platform integrators, i.e. people who build Mbed TLS with a specific set of drivers. Concrete steps to select and configure drivers. Work in progress.

## Requirements

In the design of PSA Crypto, there is a concept of hardware drivers which can be written to support implementing one of the many operation-related calls as defined by the core. This means any given configuration of PSA Crypto may be required to link against 0, 1 or more different driver implementations.

In order to support this, and not have to spend the runtime resources to do this through dynamic (runtime) registration, the decision has been made to have a 'driver dispatch' compile unit, which is intended to be autogenerated. This dispatch file contains an implementation of all calls which can be hardware-accelerated, and depending on which drivers are passed at autogeneration time, calls the relevant driver(s) for each dispatch call.

## Proposed design 

What a driver looks like from a driver developer's point of view
### Example driver:
Throughout this document, references and examples will be given using an example driver, to make the document more tangible.

{
    "prefix":       "sli_se_opaque",
    "type":         "opaque",
    "location":     [1],
    "headers":      ["sli_se_opaque_types.h", "sli_se_opaque_functions.h"],
    "capabilities": [
        {  
            "_comment":     "This driver needs to have its init function called upon psa_crypto_init() before use",
            "entry_points": ["init"]
        },
        {
            "_comment":     "This driver has both MAC single-shot and multipart support for AES-128/AES-192 and AES-256",
            "entry_points": ["mac_compute", "mac_multipart"],
            "algorithms":   ["PSA_ALG_CBC_MAC",
                             "PSA_ALG_CMAC"],
            "key_types":    ["PSA_KEY_TYPE_AES"],
            "key_sizes":    [128, 192, 256]
        }, 
 
        {
            "_comment":     "Overload using the mac_compute entry point for HMAC as well, with a different key type",
            "entry_points": ["mac_compute"],
            "algorithms":   ["PSA_ALG_HMAC"],
            "key_types":    ["PSA_KEY_TYPE_HMAC"],
            "key_sizes":    [160, 224, 256, 384, 512]
        },
        {
            "_comment":     "The SLI SE opaque driver needs to support import/export/generate of all opaque keys",
            "entry_points": ["import_key", "export_key", "export_public_key", "generate_key", "copy_key"]
        },
        {
            "_comment":     "The SLI SE opaque driver is used to access the SE's builtin keys",
            "entry_points": ["get_builtin_key"]
        }
    ]
},
{
    "prefix":       "sli_se_transparent",
    "type":         "transparent",
    "location":     [0]
    "headers":      ["sli_se_transparent_types.h", "sli_se_transparent_functions.h"],
    "capabilities": [
        {  
            "_comment":     "This driver needs to have its init function called upon psa_crypto_init() before use",
            "depend_on":    ["<config_macro>"]
            "entry_points": ["init"]
        },
        {
            "_comment":     "The SLI SE transparent driver supports import/export_public/generate for ECC keys",
            "entry_points": ["import_key", "export_public_key", "generate_key"]
        },
        {
            "_comment":     "The SLI SE transparent driver ECC sign/verify",
            "depend_on":    ["<config_macro>"]
            "entry_points": ["sign_hash", "sign_message", "verify_hash", "verify_message"],
            "algorithms":   ["PSA_ALG_ECDSA(PSA_ALG_SHA_224)",
                             "PSA_ALG_ECDSA(PSA_ALG_SHA_256)",
                             "PSA_ALG_ECDSA(PSA_ALG_SHA_384)",
                             "PSA_ALG_ECDSA(PSA_ALG_SHA_512)"],
            "key_types":    ["PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)",
                             "PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_K1)"],
            "key_sizes":    [192, 224, 256, 384, 512],
            "fallback":     false
        },
        {
            "_comment":     "The SLI SE transparent driver supports hashing w/ fallback",
            "entry_points": ["hash_compute", "hash_multipart"],
            "algorithms":   ["PSA_ALG_SHA_1",
                             "PSA_ALG_SHA_224",
                             "PSA_ALG_SHA_256",
                             "PSA_ALG_SHA_384",
                             "PSA_ALG_SHA_512"],
            "fallback": true
        },
        {
            "_comment":     "The SLI SE transparent driver supports oneshot cipher",
            "entry_points": ["cipher_encrypt", "cipher_decrypt"],
            "algorithms":   ["PSA_ALG_ECB_NO_PADDING",
                             "PSA_ALG_CTR",
                             "PSA_ALG_CFB",
                             "PSA_ALG_OFB",
                             "PSA_ALG_CBC_NO_PADDING",
                             "PSA_ALG_CBC_PKCS7",
                             "PSA_ALG_STREAM_CIPHER"],
            "key_types":    ["PSA_KEY_TYPE_AES",
                             "PSA_KEY_TYPE_CHACHA20"],
            "key_sizes":    [128, 192, 256],
            "fallback": false
        },
        {
            "_comment":     "The SLI SE transparent driver supports multipart cipher",
            "entry_points": ["cipher_encrypt_multipart", "cipher_decrypt_multipart"],
            "algorithms":   ["PSA_ALG_ECB_NO_PADDING",
                             "PSA_ALG_CTR",
                             "PSA_ALG_CFB",
                             "PSA_ALG_OFB",
                             "PSA_ALG_CBC_NO_PADDING",
                             "PSA_ALG_CBC_PKCS7"],
            "key_types":    ["PSA_KEY_TYPE_AES"],
            "key_sizes":    [128, 192, 256],
            "fallback": false
        },
        {
            "_comment":     "The SLI SE transparent driver supports CBC-MAC and CMAC multipart and oneshot",
            "entry_points": ["mac_compute", "mac_multipart"],
            "algorithms":   ["PSA_ALG_CBC_MAC",
                             "PSA_ALG_CMAC"],
            "key_types":    ["PSA_KEY_TYPE_AES"],
            "key_sizes":    [128, 192, 256],
            "fallback": false
        },
        {
            "_comment":     "The SLI SE transparent driver supports in addition oneshot HMAC",
            "entry_points": ["mac_compute"],
            "algorithms":   ["PSA_ALG_HMAC"],
            "key_types":    ["PSA_KEY_TYPE_HMAC"],
            "key_sizes":    [160, 224, 256, 384, 512],
            "fallback": false
        },
        {
            "_comment":     "The SLI SE transparent driver supports oneshot AEAD over CCM/GCM/ChaCha20",
            "entry_points": ["aead_encrypt", "aead_decrypt"],
            "algorithms":   ["PSA_ALG_CCM",
                             "PSA_ALG_GCM",
                             "PSA_ALG_CHACHA20_POLY1305"],
            "key_types":    ["PSA_KEY_TYPE_AES",
                             "PSA_KEY_TYPE_CHACHA20"],
            "key_sizes":    [128, 192, 256],
            "fallback": false
        },
        {
            "_comment":     "The SLI SE transparent driver supports multipart AEAD for GCM only",
            "entry_points": ["aead_encrypt_multipart", "aead_decrypt_multipart"],
            "algorithms":   ["PSA_ALG_GCM"],
            "key_types":    ["PSA_KEY_TYPE_AES"],
            "key_sizes":    [128, 192, 256],
            "fallback": false
        }
    ]
}

### A brief description of driver capabilities

The driver interface specification gives a good enough detailed explanation of capabilities that can be declared by each driver. The capabilities declared by a driver denotes what is supported by the driver and serves to alternatively compile in a software fallback for the unsupported algorithms/ key types / key sizes[1], thereby deriving that information from the driver JSON.

The capability "fallback" is only applicable for transparent drivers. The "prefix"_"type"_"entry_point" defines the function name servicing the capability in the driver, this can be over written with a "name" property. The current documentation does not clearly state how the name property needs to be defined, but a good candidate would probably look like this "name" : [[ "sign_hash", "sli_crypto_sign_hash"],["verify_hash","sli_crypto_verify_hash"]] (This could be altered a bit while scripting, but it is a need and not something that can be pushed to a later release.)

The application defines a config file keeping in mind the crypto operations and key types that it wants. The driver's capabilities define the crypto operations and key types that can be supported by the driver.The delta between the two needs to be enabled as software fallback or enabled on an alternate driver on the same location[1]. If fallback is declared true by the driver for a capability it is understood that the said capability is not fully supported by the driver and needs SW fallback support/ support from additional drivers. This is the main purpose of defining the capabilities that the driver has to offer.

Today only some parts of the implementation of the builtin functions are controlled by configurations, or at least it is not the case for all builtin calls[2].
This will need to be refactored to have a preprocessor config control each builtin implementation, while status quo remains for algorithm specific enables.

### Configuration trickle down based on driver capabilities 

Configuration trickle for opaque drivers is straight forward, what the driver does not support on a location are just not supported.
A configuration match and trickle is however necessiated for a transparent driver.
To understand the flow of how config will need to work, let's look at this example.

User config:

PSA_WANT_ALG_SHA_1,
PSA_WANT_ALG_SHA_224,
PSA_WANT_ALG_SHA_384,
PSA_WANT_ALG_MD5

Driver capabilities :
{"capabilities" = [
  {"entry_points": ["hash_multipart"],"algorithms": ["PSA_ALG_SHA256",PSA_WANT_ALG_SHA_384]},
  {"entry_points": ["hash_multipart"],"algorithms": ["PSA_ALG_SHA_1], "fallback": true},
]}
 
In the above example PSA_ALG_MD5 is not supported by the transparent driver, PSA_ALG_SHA256 and PSA_WANT_ALG_SHA_384 are fully supported, and PSA_ALG_SHA_1 is partially supported marked by setting fallback as true, this could mean a few key sizes for SHA-1 are unsupported.
The capabilities declared by the driver will need to be translated and autogenerated into a driver specific config to be included in config_psa.h
In the above case this translates to 

"PSA_ALG_SHA_224", => MBEDTLS_PSA_ACCEL_ALG_SHA_224
"PSA_ALG_SHA_384", => MBEDTLS_PSA_ACCEL_ALG_SHA_384

Since PSA_ALG_SHA_1 is only partially supported we don't declare it as accelerated.
In PSA Crypto config's current behavior if MBEDTLS_PSA_ACCEL_ALG_xxx is disabled and PSA_WANT_ALG_xxx is enabled, the built in fallback will get enabled.

#if defined(PSA_WANT_ALG_MD5) && !defined(MBEDTLS_PSA_ACCEL_ALG_MD5)
#define MBEDTLS_PSA_BUILTIN_ALG_MD5 1
#define MBEDTLS_MD5_C
#endif

With the above we have the builtin support declared for both SHA_1 and MD5 i.e, MBEDTLS_PSA_BUILTIN_ALG_MD5 and MBEDTLS_PSA_BUILTIN_ALG_SHA_1

### Description of the autogenerated logic
The autogenerated `psa_crypto_driver_wrappers.c` file's goal is to "dispatch" driver-implementable functions to drivers supporting the dispatchable operation. 

While the "dispatch" to the drivers is what would be autogenerated and spliced in, our base template will simply be a stripped down skeleton of the `psa_crypto_driver_wrappers.c` file. The new 'psa_crypto_driver_wrapper.c' file, also the template file,  will continue to host

Some of the existing legacy code from under MBEDTLS_PSA_CRYPTO_SE_C, default house keeping as required by each entry point, and the built-in fallback.
The dispatch of functions can be broadly classified as one-shot functions and multipart functions. While the following description is a bit of a digression from the autogeneration, it deserves a brief explanation to clarify on the classification of dispatch function types in PSA Crypto, and how they differ in functionality changing the way they will need to be auto generated. 

#### Dispatching one-shot functions

One-shot functions are functions which don't handle/keep state between calls. After the function call returns, the entire operation is done and finished.
There are two classes of these operations.

##### One-shot functions using a key (input or output)

One-shot functions which use or produce a key need to first look at the location value of the key. 

Example: `psa_driver_wrapper_aead_encrypt`

For location value `PSA_KEY_LOCATION_LOCAL_STORAGE` (transparent key):
Call all transparent drivers which expose this operation (have declared an associated 'entry_point' in their descriptor) until either one of them returns a status code different from NOT_SUPPORTED, or no more drivers are available to be tried.
If one of the drivers called was declared with 'fallback==true', then if all drivers return NOT_SUPPORTED[1], call the built-in version of this driver entry point and return its status
If all calls result in NOT_SUPPORTED, the return value of the dispatch is NOT_SUPPORTED
For location values other than `PSA_KEY_LOCATION_LOCAL_STORAGE`:
Call the operation on the opaque driver declared at that location value if the driver JSON declared such an operation as part of its 'functions', and return its status

Note: 
The location value macro names for opaque drivers have not been standardized yet. It is understood between Silicon Labs and ARM that hardcoding / hard-assigning location values to specific drivers will be required, as the location value of an opaque driver is not allowed to change as soon as there are persistent keys in storage.
Approaches:we could make 
(1) The location another property for opaque drivers. The autogenerator script should handle validation against already generated locations and throw an error.
(2) Generate the location ID in sequence with the problem that a change in sequence could nullify persistant keys at a given location.

For location values which are present in the system, but for which there is no implementation in that driver for this specific function, return NOT_SUPPORTED
For location values not present in the system, return INVALID_ARGUMENT

##### One-shot functions not using a key

One-shot functions without key input/output can just try all drivers in turn until one succeeds or errors out with a code different from NOT_SUPPORTED.

Example: `psa_driver_wrapper_hash_compute`

#### Dispatching multi-part functions

Multipart functions are functions which need to track state in-between calls. This state is usually in a variable called 'ctx' or 'context' (or derivative).

Multipart APIs mean that there is one or more functions to start the operation, one or more to continue the operation in various ways, and one or more to finish the operation. Additionally there may be a function to cancel/abort an ongoing operation.

Example: `psa_driver_wrapper_cipher_xxx` where xxx is one of [encrypt_setup, decrypt_setup, set_iv, update, finish, abort ]

For dispatching a multipart function, the context / state object needs to contain a member which contains an identifier for the driver which is processing the operation. There are no provisions for intermixing different drivers using the same context (since a context is driver-specific), so once an operation is started on a driver, all subsequent calls for that same operation need to be dispatched to the same driver.

##### Starting an operation:

Try all relevant drivers (i.e. all drivers with an implementation of this function in case of non-key algorithms, or all drivers for this location in case of key algorithms), at the end possible a PSA Core builtin fallback implementation. The first one to return 'success' gets its ID assigned to the operation structure
If at any point an error other than NOT_SUPPORTED is returned, that error gets bubbled up and no operation is started. If all return NOT_SUPPORTED, then NOT_SUPPORTED is returned.

##### Continuing an operation:

Call the driver associated with the stored ID from the operation structure.
If the ID is unknown, return a consistency error. If the driver associated with the operation's driver ID does not implement this function, return NOT_SUPPORTED

##### Finishing/canceling an operation:

Call the finish/cancel function on the associated driver if the driver implements such a function, reset the stored driver ID to 0. If the ID is unknown non-zero, return a consistency error. Just like one shot operations, the multi part operation can include operations with/without a key, and is categorized similar to a one shot operation based on location of the key, as required.

### Proposed autogeneration logic
High-level, and in pseudocode, the driver dispatch file would look something like:

--- header section ---
[header]
[header includes for PSA Core builtin fallback functions]
[test driver declaration]
 
 
[for each declared driver]
  [include all headers required by the driver]
  [set marker to indicate at least one driver is present]
[endfor]
 
[Set ID for operations using the builtin fallback logic to '1']
[for each declared driver]
  [Set macro <prefix>_<type>_DRIVER_ID to a sequential value. This ID will be set on in-progress multipart operation contexts to track which driver is doing an operation, so it does not relate to the location value.]
[endfor]
 
 
--- function dispatch ---
[for each dispatchable oneshot non-key function]
  function body open 
  legacy code retained
  [for each driver containing an implementation of this dispatchable function]
    status = result of calling driver entry point
    if status != NOT_SUPPORTED, return status
  [endfor]
  [if one of the drivers had the fallback flag]
  // This will be controlled by a config MBEDTLS_PSA_BUILTIN_<functionality>,
  // the config would be enabled if fallback is true for any driver.
    status = result of calling the PSA Core builtin implementation of this dispatchable function
    if status != NOT_SUPPORTED, return status
  [endif]
  void all input arguments
  return NOT_SUPPORTED
  function body close // includes all housekeeping required for a function, any cleanup etc.
[endfor]
 
 
[for each dispatchable oneshot key-using function]
  function body open
  get location value for key lifetime
  switch(location)
    case LOCAL_STORAGE:
      [for each transparent driver containing an implementation of this dispatchable function]
        status = result of calling driver entry point
        if status != NOT_SUPPORTED, return status
      [endfor]
      [if one of the drivers had the fallback flag]
      // This will be controlled by a config MBEDTLS_PSA_BUILTIN_<functionality>,
      // the config would be enabled if fallback is true for any driver.
        status = result of calling the PSA Core builtin implementation of this dispatchable function
        if status != NOT_SUPPORTED, return status
    [endif]
    [for each opaque driver containing an implementation of this dispatchable function]
    case <opaque driver's location value>:
      return status from calling the opaque driver's implementation of the dispatched function
    [endfor]
    default:
      void all input arguments
      return INVALID_ARGUMENT
  void all input arguments
  return NOT_SUPPORTED
  function body close
[endfor]
 
[for each dispatchable multipart setup non-key function]
  function body open 
  legacy code retained
  [for each driver containing an implementation of this dispatchable function]
    status = result of calling driver entry point
    if status == PSA_SUCCUSS, set operation->id to <prefix>_<type>_DRIVER_ID
    if status != NOT_SUPPORTED, return status
  [endfor]
  [if one of the drivers had the fallback flag]
    // This will be controlled by a config MBEDTLS_PSA_BUILTIN_<functionality>,
    // the config would be enabled if fallback is true for any driver.
    status = result of calling the PSA Core builtin implementation of this dispatchable function
    if status == PSA_SUCCUSS, set operation->id to <builtin>_ID
    if status != NOT_SUPPORTED, return status
  [endif]
  void all input arguments
  return NOT_SUPPORTED
  function body close
[endfor]
 
 
[for each dispatchable multipart setup key-using function]
  function body open
  get location value for key lifetime
  switch(location)
    case LOCAL_STORAGE:
      [for each transparent driver containing an implementation of this dispatchable function]
        status = result of calling driver entry point
        if status == PSA_SUCCUSS, set operation->id to <prefix>_<type>_DRIVER_ID
        if status != NOT_SUPPORTED, return status
      [endfor]
      [if one of the drivers had the fallback flag]
        // This will be controlled by a config MBEDTLS_PSA_BUILTIN_<functionality>,
        // the config would be enabled if fallback is true for any driver.
        status = result of calling the PSA Core builtin implementation of this dispatchable function
        if status == PSA_SUCCUSS, set operation->id to <builtin>_ID
        if status != NOT_SUPPORTED, return status
      [endif]
      void all input arguments
      return NOT_SUPPORTED
    [for each opaque driver containing an implementation of this dispatchable function]
    case <opaque driver's location value>:
      if status == PSA_SUCCUSS, set operation->id to <prefix>_<type>_DRIVER_ID
      return status from calling the opaque driver's implementation of the dispatched function
    [endfor]
    default:
      void all input arguments
      return INVALID_ARGUMENT
  function body close
[endfor]
 
 
 
[for each dispatchable multipart (all other) function]
  function body open 
  legacy code retained
  get id of operation
  switch(id)
    [for each driver containing an implementation of this dispatchable function]
    case <prefix>_<type>_DRIVER_ID:
      status = result of calling driver entry point
      return status
    [endfor]
    [if one of the drivers had the fallback flag]
    // This will be controlled by a config MBEDTLS_PSA_BUILTIN_<functionality>,
    // the config would be enabled if fallback is true for any driver.
    case <BUILTIN>_ID:
      status = result of calling the PSA Core builtin implementation of this dispatchable function
      return status
    [endif]
    default:
      void all input arguments
      return INVALID_ARGUMENT
  function body close // includes all housekeeping required for a function, any cleanup etc.
[endfor]

### Known problems
Some of the functions in the psa_crypto library currently don't invoke a driver_wrapper routine eg psa_asymmetric_encrypt(), these will have to be refactored.
All built-in functions are not controlled by appropriate config macros, this will need to be improved to add new config macros for all builtin implemetations.

### Documentation updates
The driver interface specification will need to be updated for any new capability/ property addition to the JSON.
The "depends_on" is a new capability that will need to be added to include any controllable preprocessor logic.
Till such time that the value of key locations per driver is standardized, the key location will need to be passed as a property.
Also clear examples of how each capability needs to be defined, with an example base transparent file in the build system with all fallback as true to be used as template.

### Subsequent versions
Clearly all options cannot be brought in at one go, but in the process of this design some options are/will be identified as good to have in subsequent versions.

Enhancements/ supports moved out of version 1.0 are

(1) Including support for multiple drivers within the same location.
(2) Moving the built-in functionality into a driver declaration, albeit a default one.(This can be considered as a improvement in readability)
(3) key_sizes as a capability will  be supported once we define more expressive macros to control different algorithms.
(4) Auto config based on proposal will be attempted in the first version.
(5) Do away with legacy code under MBEDTLS_PSA_CRYPTO_SE_C or get it to be autogenrated as a template substitute from a predefined file to improve readability.

### Validations

The main validation would be to depend on the built in test suites.
As part of scripting we will develop a JSON validator to ensure it is semantically correct to avoid generating wrong code.
Some test vectors/suites to validate SW fallback enable.

### Scripting
Using Python3.0 with Jinja2 /MAKO. 


