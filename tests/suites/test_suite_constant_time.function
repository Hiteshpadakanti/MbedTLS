/* BEGIN_HEADER */

/** \file test_suite_constant_time.function
 *
 * Functional testing of functions in the constant_time module.
 *
 * The tests are instrumented with #TEST_CF_SECRET and #TEST_CF_PUBLIC
 * (see tests/include/test/constant_flow.h) so that running the tests
 * under MSan or Valgrind will detect a non-constant-time implementation.
 */

#include "mbedtls/constant_time.h"
#include "constant_time_internal.h"
#include "constant_time_invasive.h"

#if defined(MBEDTLS_BIGNUM_C)
#include "bignum_core.h"
#endif

#include <test/constant_flow.h>

static const char base64_digits[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/* END_HEADER */

/* BEGIN_CASE depends_on:MBEDTLS_TEST_HOOKS */
void mask_of_range( int low_arg, int high_arg )
{
    unsigned char low = low_arg, high = high_arg;
    unsigned c;
    for( c = 0; c <= 0xff; c++ )
    {
        mbedtls_test_set_step( c );
        TEST_CF_SECRET( &c, sizeof( c ) );
        unsigned char m = mbedtls_ct_uchar_mask_of_range( low, high, c );
        TEST_CF_PUBLIC( &c, sizeof( c ) );
        TEST_CF_PUBLIC( &m, sizeof( m ) );
        if( low <= c && c <= high )
            TEST_EQUAL( m, 0xff );
        else
            TEST_EQUAL( m, 0 );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BASE64_C */
void base64_enc_chars( )
{
    for( unsigned value = 0; value < 64; value++ )
    {
        mbedtls_test_set_step( value );
        TEST_CF_SECRET( &value, sizeof( value ) );
        unsigned char digit = mbedtls_ct_base64_enc_char( value );
        TEST_CF_PUBLIC( &value, sizeof( value ) );
        TEST_CF_PUBLIC( &digit, sizeof( digit ) );
        TEST_EQUAL( digit, base64_digits[value] );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BASE64_C */
void base64_dec_values( )
{
    char *p;
    signed char expected;

    for( unsigned c = 0; c <= 0xff; c++ )
    {
        mbedtls_test_set_step( c );
        /* base64_digits is 0-terminated. sizeof()-1 excludes the trailing 0. */
        p = memchr( base64_digits, c, sizeof( base64_digits ) - 1 );
        if( p == NULL )
            expected = -1;
        else
            expected = p - base64_digits;
        TEST_CF_SECRET( &c, sizeof( c ) );
        signed char actual = mbedtls_ct_base64_dec_value( c );
        TEST_CF_PUBLIC( &c, sizeof( c ) );
        TEST_CF_PUBLIC( &actual, sizeof( actual ) );
        TEST_EQUAL( actual, expected );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SSL_SOME_SUITES_USE_TLS_CBC */
void ssl_cf_memcpy_offset( int offset_min, int offset_max, int len )
{
    unsigned char *dst = NULL;
    unsigned char *src = NULL;
    size_t src_len = offset_max + len;
    size_t secret;

    ASSERT_ALLOC( dst, len );
    ASSERT_ALLOC( src, src_len );

    /* Fill src in a way that we can detect if we copied the right bytes */
    mbedtls_test_rnd_std_rand( NULL, src, src_len );

    for( secret = offset_min; secret <= (size_t) offset_max; secret++ )
    {
        mbedtls_test_set_step( (int) secret );

        TEST_CF_SECRET( &secret, sizeof( secret ) );
        mbedtls_ct_memcpy_offset( dst, src, secret,
                                  offset_min, offset_max, len );
        TEST_CF_PUBLIC( &secret, sizeof( secret ) );
        TEST_CF_PUBLIC( dst, len );

        ASSERT_COMPARE( dst, len, src + secret, len );
    }

exit:
    mbedtls_free( dst );
    mbedtls_free( src );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BIGNUM_C */
void mpi_core_lt_ct( data_t * input_X, data_t * input_Y, int input_ret )
{
    #define MAX_LEN 64
    mbedtls_mpi_uint X[MAX_LEN];
    mbedtls_mpi_uint Y[MAX_LEN];
    unsigned exp_ret = input_ret;
    unsigned ret;
    size_t len = CHARS_TO_LIMBS(
                    input_X->len > input_Y->len ? input_X->len : input_Y->len );

    TEST_ASSERT( len <= MAX_LEN );

    TEST_ASSERT( mbedtls_mpi_core_read_be( X, len, input_X->x, input_X->len )
                 == 0 );
    TEST_ASSERT( mbedtls_mpi_core_read_be( Y, len, input_Y->x, input_Y->len )
                 == 0 );

    TEST_CF_SECRET( X, len * sizeof( mbedtls_mpi_uint ) );
    TEST_CF_SECRET( Y, len * sizeof( mbedtls_mpi_uint ) );

    ret = mbedtls_mpi_core_lt_ct( X, Y, len );

    TEST_CF_PUBLIC( X, len * sizeof( mbedtls_mpi_uint ) );
    TEST_CF_PUBLIC( Y, len * sizeof( mbedtls_mpi_uint ) );
    TEST_CF_PUBLIC( &ret, sizeof( ret ) );

    TEST_EQUAL( ret, exp_ret );

exit:
    ;

    #undef MAX_LEN
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BIGNUM_C */
void mbedtls_mpi_lt_mpi_ct( int size_X, char * input_X,
                            int size_Y, char * input_Y,
                            int input_ret, int input_err )
{
    unsigned ret = -1;
    unsigned input_uret = input_ret;
    mbedtls_mpi X, Y;
    mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y );

    TEST_ASSERT( mbedtls_test_read_mpi( &X, input_X ) == 0 );
    TEST_ASSERT( mbedtls_test_read_mpi( &Y, input_Y ) == 0 );

    TEST_ASSERT( mbedtls_mpi_grow( &X, size_X ) == 0 );
    TEST_ASSERT( mbedtls_mpi_grow( &Y, size_Y ) == 0 );

    TEST_ASSERT( mbedtls_mpi_lt_mpi_ct( &X, &Y, &ret ) == input_err );
    if( input_err == 0 )
        TEST_ASSERT( ret == input_uret );

exit:
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y );
}
/* END_CASE */
