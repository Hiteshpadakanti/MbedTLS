/* BEGIN_HEADER */

/* This test module exercises the platform_* module. Since, depending on the
 * underlying operating system, the time routines are not always reliable,
 * this suite only performs very basic sanity checks of the timing API.
 */

#include <limits.h>

#if defined(MBEDTLS_HAVE_TIME)
#include "mbedtls/platform_time.h"

#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \
    defined(__MINGW32__) || defined(_WIN64)
#include <windows.h>
#elif _POSIX_C_SOURCE >= 199309L
#include <time.h>
#else
#include <unistd.h>
#endif
void sleep_ms(int milliseconds)
{
#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \
    defined(__MINGW32__) || defined(_WIN64)
    Sleep(milliseconds);
#elif _POSIX_C_SOURCE >= 199309L
    struct timespec ts;
    ts.tv_sec = milliseconds / 1000;
    ts.tv_nsec = (milliseconds % 1000) * 1000000;
    nanosleep(&ts, NULL);
#else
    usleep(milliseconds * 1000);
#endif
}

#endif
/* END_HEADER */

/* BEGIN_DEPENDENCIES */

/* END_DEPENDENCIES */

/* BEGIN_CASE depends_on:MBEDTLS_HAVE_TIME */

/* `time_delay_milliseconds()` and `time_delay_seconds()` might be fail due to
 * `signal interrupt`, `discontinues jumps` and `incremental adjustment`. The
 * test functions run 3 iteration to ignore the failures caused by those
 * conditions.
 * - `signal interrupt`  : That is introduced by `sleep_ms()`. `nanosleep()` and
 *                         `usleep()` can be interrupted by signal.
 * - `discontinues jumps`: `CLOCK_REALTIME` can be manually changed. When it
 *                         happens during test, the test will be failed on
 *                         Linux.
 * - `incremental adjustment`: When `incremental adjustments` are performed
 *                         during test, the end time might be not in tolerance
 *                         windows. If `incremental adjustments` end in 2nd
 *                         iteration, it might fail also, we try 3rd iteration.
 *
 * `time_delay_milliseconds()` and `time_delay_seconds()` will re-try 3 times,
 * so we design a +/- 1 second expect window.
 */
void time_delay_milliseconds(int delay_ms)
{
    mbedtls_ms_time_t current;
    mbedtls_ms_time_t expected_end;
    mbedtls_ms_time_t diff_ms;

    current = mbedtls_ms_time();
    expected_end = current + delay_ms;
    sleep_ms(delay_ms);
    diff_ms = mbedtls_ms_time() - expected_end;
    if (diff_ms < 1000 && -1000 < diff_ms) {
        goto exit;
    }

    /* When `signal interrupt`, `discontinues jumps` or `incremental adjustment`
     * happens in previous iteration, try again.*/
    current = mbedtls_ms_time();
    expected_end = current + delay_ms;
    sleep_ms(delay_ms);
    diff_ms = mbedtls_ms_time() - expected_end;
    if (diff_ms < 1000 && -1000 < diff_ms) {
        goto exit;
    }

    /* When `incremental adjustment` end in previous iteration, try again.*/
    current = mbedtls_ms_time();
    expected_end = current + delay_ms;
    sleep_ms(delay_ms);
    diff_ms = mbedtls_ms_time() - expected_end;
    TEST_LE_S(diff_ms, 1000 - 1);
    TEST_LE_S(-1000 + 1, diff_ms);
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_HAVE_TIME */

/* See comments of `time_delay_millisesonds()`
 */
void time_delay_seconds(int delay_secs)
{
    mbedtls_time_t current;
    mbedtls_time_t expected_end;
    mbedtls_time_t diff_secs;

    current = mbedtls_time(NULL);
    expected_end = current + delay_secs;
    sleep_ms(delay_secs * 1000);
    diff_secs = mbedtls_time(NULL) - expected_end;
    if (diff_secs <= 1 && -1 <= diff_secs) {
        /* Test pass */
        goto exit;
    }
    ;

    /* When `signal interrupt`, `discontinues jumps` or `incremental adjustment`
     * happens in previous iteration, try again.*/
    current = mbedtls_time(NULL);
    expected_end = current + delay_secs;
    sleep_ms(delay_secs * 1000);
    diff_secs = mbedtls_time(NULL) - expected_end;
    if (diff_secs <= 1 && -1 <= diff_secs) {
        /* Test pass */
        goto exit;
    }
    ;

    /* When `incremental adjustment` end in previous iteration, try again.*/
    current = mbedtls_time(NULL);
    expected_end = current + delay_secs;
    sleep_ms(delay_secs * 1000);
    diff_secs = mbedtls_time(NULL) - expected_end;

    TEST_LE_S(diff_secs, 1);
    TEST_LE_S(-1, diff_secs);
}
/* END_CASE */
