#!/usr/bin/env python3
"""Generate code to convert numerical values into symbolic names.
"""
# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import glob
import re
from typing import Dict, Set

import scripts_path # pylint: disable=unused-import
from mbedtls_dev import build_tree
from mbedtls_dev import typing_util

class ConstantNames:
    """Collect C constant names."""

    # Mapping of category names to the name of their representation type.
    # Categories that are not listed here are assumed to have the same
    # name as their representation type.
    CATEGORY_TYPES = {
        'error': 'int',
    }

    # Recognized prefixes for preprocessor macros, mapped to their
    # category name.
    MACRO_PREFIXES = {
        'MBEDTLS_ERR_': 'error',
        'PSA_ERROR_': 'psa_status_t',
    }

    def __init__(self) -> None:
        self.headers = set() #type: Set[str]
        # {type_name: {value_name, ...}, ...}
        self.macros = {} #type: Dict[str, Set[str]]
        for category in self.MACRO_PREFIXES.values():
            self.macros.setdefault(category, set())

    # Prefix to strip to go from a relative file path to an include path.
    STRIP_INCLUDE_PREFIX_RE = re.compile(r'include/')

    def register_include(self, filename: str) -> None:
        """Register a header to include for value definitions.

        The filename must be relative to the Mbed TLS root directory.
        """
        # We need a path with slashes, but we might be getting a Windows path.
        filename = filename.replace('\\', '/')
        filename = re.sub(self.STRIP_INCLUDE_PREFIX_RE, '', filename)
        self.headers.add(filename)

    # Match a macro definition with one of the recognized prefixes.
    MACRO_DEFINITION_RE = re.compile(
        r'\s*#\s*define\s+(({})\w+)'.format(
            '|'.join(MACRO_PREFIXES.keys())
        ), re.A)

    def collect_line(self, line: str) -> bool:
        """Collect constant names from the specified line, if any.

        Return True if something was collected, otherwise False.
        """
        m = self.MACRO_DEFINITION_RE.match(line)
        if m:
            category = self.MACRO_PREFIXES[m.group(2)]
            self.macros[category].add(m.group(1))
            return True
        return False

    # Match the printable ASCII bytes at the beginning of a byte string
    ASCII_BYTES_RE = re.compile(rb'[ -~]+')

    def collect_from_file(self, filename: str) -> None:
        """Collect constant names from the specified file."""
        for line_bytes in open(filename, 'rb'):
            m = self.ASCII_BYTES_RE.match(line_bytes)
            if m:
                if self.collect_line(m.group(0).decode('ascii')):
                    self.register_include(filename)

    def write_code_header(self, out: typing_util.Writable) -> None:
        out.write("""\
/* Automatically generated by generate_value_names.py. Do not edit! */

""")
        for header in sorted(self.headers):
            out.write('#include <{}>\n'.format(header))

    @staticmethod
    def write_code_footer(out: typing_util.Writable) -> None:
        out.write("""
/* End of file generated by generate_value_names.py */
""")

    def write_macro_type(self, out: typing_util.Writable,
                         category: str, values: Set[str]) -> None:
        """Output the code of a C function to get value names for a category."""
        representation_type = self.CATEGORY_TYPES.get(category, category)
        out.write("""
const char *mbedtls_test_get_name_of_{}({} value) {{
    switch (value) {{
""".format(category, representation_type))
        for value_name in sorted(values):
            #pylint: disable=duplicate-string-formatting-argument
            out.write("""\
#if defined({})
        case {}: return "{}";
#endif
""".format(value_name, value_name, value_name))
        out.write("""\
        default: return NULL;
    }}
}}
""".format())

    def write_code(self, filename: str) -> None:
        """Write a C file that defines functions to get value names."""
        with open(filename, 'w') as out:
            self.write_code_header(out)
            for type_name in sorted(self.macros):
                self.write_macro_type(out, type_name, self.macros[type_name])
            self.write_code_footer(out)

CONFIG_HEADER_RE = re.compile(r'[^A-Za-z0-9]config[^A-Za-z0-9]', re.A)

def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--output', '-o', metavar='FILE',
                        default='tests/src/value_names_generated.c',
                        help='Output file for the generated C code')
    options = parser.parse_args()
    build_tree.chdir_to_root()
    constant_names = ConstantNames()
    for filename in glob.glob('include/*/*.h'):
        # Skip configuration-related headers. They can't be included directly.
        # They don't contain names we currently care about, so that's ok.
        # If this code later needs configuration symbols, we should just
        # include all non-config headers.
        if re.search(CONFIG_HEADER_RE, filename):
            continue
        constant_names.collect_from_file(filename)
    constant_names.write_code(options.output)

if __name__ == '__main__':
    main()
