#!/usr/bin/env python3
"""Parse code written for Mbed TLS 2, looking for things to adapt for Mbed TLS 3.

Mbed TLS headers must be present in the include path. That is, you need to
pass the same -I option(s) that you would to compile your program.

This script uses the clang python bindings (``pip3 install --user clang``).
"""

# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import collections
import json
import os
import re
import sys
from typing import Dict, FrozenSet, List, Optional

import clang.cindex #type: ignore
from clang.cindex import Cursor, SourceLocation, TranslationUnit, Type
from clang.cindex import CursorKind, TypeKind

from mbedtls_dev import typing_util


class Knowledge():
    """Knowledge about Mbed TLS 3."""
    # Dear Pylint, if we build it, the methods will come.
    #pylint: disable=too-few-public-methods

    DATA_FILE = 'data_files/2to3-knowledge-generated.json'

    def __init__(self) -> None:
        data_file_name = os.path.join(os.path.dirname(__file__),
                                      self.DATA_FILE)
        with open(data_file_name) as data_file:
            data = json.load(data_file)
        # Ideally we would validate the data here. But since the JSON file
        # is automatically generated by us (specifically, by
        # generate_public_fields.py), there's a low risk that it's invalid.
        # So just assume that the expected data is present and has the right
        # structure.
        self.public_fields = \
            {k: frozenset(v) for k, v in data['public_fields'].items()} \
            # type: Dict[str, FrozenSet[str]]

    PRIVATE_FIELD_ADVICE = {
        'mbedtls_rsa_context': {
            'N': 'Use mbedtls_rsa_get_len().'
        },
    }
    def private_field_advice(self, type_name, field_name) -> Optional[str]:
        # Provide the same advice if the code has already been edited to
        # use MBEDTLS_PRIVATE(field_name).
        if field_name.startswith('private_'):
            field_name = field_name[8:]
        return self.PRIVATE_FIELD_ADVICE.get(type_name, {}).get(field_name)

class Ast:
    """Abstract representation of the source code."""

    def __init__(self, options) -> None:
        """Prepare for analysis of C source files."""
        self.knowledge = Knowledge()
        if options.clang_library_file:
            clang.cindex.Config.set_library_file(options.clang_library_file)
        self.parse_options = []
        for d in options.include:
            self.parse_options.append('-I' + d)
        self.index = clang.cindex.Index.create()
        self.files = collections.OrderedDict() #type: Dict[str, TranslationUnit]
        self.errors = 0

    @staticmethod
    def report(stream: typing_util.Writable, node: Cursor,
               message: str, *args, **kwargs) -> None:
        try:
            filename = node.location.file.name
        except AttributeError:
            filename = '(unknown)'
        line = node.location.line
        stream.write('{}:{}: '.format(filename, line) +
                     message.format(*args, **kwargs) +
                     '\n')

    def note(self, node: Cursor, message: str, *args,
             advice: Optional[str] = None, **kwargs) -> None:
        if advice is not None:
            message += '\n    Suggestion: {}'
            args += (advice,)
        self.report(sys.stdout, node, message, *args, **kwargs)

    def warn(self, *args, **kwargs) -> None:
        self.report(sys.stderr, *args, **kwargs)

    def error(self, node: Cursor, message, *args, **kwargs) -> None:
        self.errors += 1
        self.warn(node, message, *args, **kwargs)

    def load(self, *filenames: str) -> None:
        """Load the AST of the given source files."""
        for filename in filenames:
            self.files[filename] = self.index.parse(filename,
                                                    self.parse_options)

    QUALIFIERS_RE = re.compile(r'\s*(const|volatile|restrict)\s+')
    def get_type_core(self, typ: Type) -> str:
        """Get the base name of a type, without qualifiers or pointers."""
        while typ.kind == TypeKind.POINTER:
            typ = typ.get_pointee()
        # There's no API function to remove qualifiers from a type,
        # so do it textually.
        return re.sub(self.QUALIFIERS_RE, r'', typ.spelling)

    def analyze_field_access(self, node: Cursor) -> None:
        """Analyze a structure or union member access node."""
        field_name = node.spelling
        lhs = next(node.get_children())
        structure_type = self.get_type_core(lhs.type)
        if structure_type in self.knowledge.public_fields and \
           field_name not in self.knowledge.public_fields[structure_type]:
            advice = self.knowledge.private_field_advice(structure_type,
                                                         field_name)
            self.note(node, 'Access to private field .{} of {}',
                      field_name, structure_type,
                      advice=advice)

    BORING_FILE_RE = re.compile(r'(?:.*/)?(mbedtls|psa)/[^/]*\.h\Z')
    def in_boring_file(self, location: SourceLocation) -> bool:
        """Whether the given location is in a file that should not be analyzed.

        This function detects Mbed TLS headers.
        """
        if not hasattr(location.file, 'name'):
            # Some artificial nodes have associated no file name.
            # Let's hope they're not important.
            return True
        filename = location.file.name
        if self.BORING_FILE_RE.match(filename):
            return True
        return False

    def analyze_file(self, tu: TranslationUnit) -> None:
        """Look for things that need to be upgraded in a translation unit."""
        for node in tu.cursor.walk_preorder():
            if self.in_boring_file(node.location):
                continue
            if node.kind == CursorKind.MEMBER_REF_EXPR:
                # foo.x or foo->x where foo has a (pointer to) struture or
                # union type.
                self.analyze_field_access(node)

    def analyze_files(self, filenames: List[str]) -> None:
        """Look for things that need to be upgraded in the given files."""
        self.load(*filenames)
        for tu in self.files.values():
            self.analyze_file(tu)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--clang-library-file',
                        help="Alternative location of libclang.so")
    parser.add_argument('--include', '-I',
                        action='append',
                        default=[],
                        help="""Directory to add to the header include path""")
    parser.add_argument('files', metavar='FILE', nargs='+',
                        help="""Files to analyze""")
    options = parser.parse_args()
    ast = Ast(options)
    ast.analyze_files(options.files)
    if ast.errors:
        sys.exit(1)

if __name__ == '__main__':
    main()
